# Python 3.12.3
"""
Хороший комментарий с направлением мысли из чатика по основам алгоротмов:
"В общем, если вдруг кому интересно: задача поиска максимального значения подвыражений решается довольно легко — достаточно при формировании очередного узла дерева выражения учитывать не только значения, полученные в результате применения оператора к его потомкам, но и самих потомков. E.G. внешняя операция == -, минимум слева == 2, максимум == 4, минимум справа == 5, максимум == 10 — исходный алгоритм, максимизируя это выражение, найдет -1 (разность наибольшего левого операнда и наименьшего правого),  мы же возьмем 10, поскольку это наибольший правый операнд и он больше любого из возможных значений разности, тем самым из исходного выражения исчезнет оператор - и его левый операнд"
"""
from sys import stdin

text = stdin.readline().rstrip()
digits = [int(text[i]) for i in range(len(text)) if i % 2 == 0]

operations = [text[i] for i in range(len(text)) if i % 2]
n = len(digits)
mins = [[(10 ** 9)] * (n + 1) for _ in range(n + 1)]
maxs = [[(-10 ** 9)] * (n + 1) for _ in range(n + 1)]

for i in range(n):
    mins[i][i] = digits[i]
    maxs[i][i] = digits[i]

for s in range(n):
    for l in range(n - s):
        r =  s + l
        for m in range(l, r):
            for m_ in range(1, min(4, r - m) + 1): # из-за того, что нужно
# смотреть и на результаты за участниками непосредственно выражения. Когда завезут правильные тесты нужно будет
# убрать этот фор и заменить в нижеследующих выражениях m_ на 1
                #print(m_, m, r)
                a = eval(f'{mins[l][m]}{operations[m]}{mins[m_ + m][r]}')
                b = eval(f'{mins[l][m]}{operations[m]}{maxs[m_ + m][r]}')
                c = eval(f'{maxs[l][m]}{operations[m]}{mins[m_ + m][r]}')
                d = eval(f'{maxs[l][m]}{operations[m]}{maxs[m_ + m][r]}')

                mins[l][r] = min(mins[l][r], a, b, c ,d)
                maxs[l][r] = max(maxs[l][r], a, b, c ,d)
print(maxs[0][n-1])
